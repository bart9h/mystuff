#!/bin/bash
# ~/.bashrc: executed by bash(1) for non-login shells.
#{{{1  prepare the environment, and load local stuff

# escape if environment already loaded
test -z "$PS1" && return

unalias -a


function _load() {
	if test -r "$1"; then
		source "$1"
	fi
}
_load "$HOME/etc/bash/functions"
prompt_color="1;37"
_load "$HOME/.bashrc_local"


#{{{1 lazy-loading of functions

for i in "$HOME/etc/bash/"*.sh; do
	f="$( basename "$i" | sed 's/\.sh$//' )"
	alias $f="call $f"
	unset f
done; unset i

function call()
{
	local f="$1"; shift
	local t="$(type -t "$f" 2>/dev/null)"

	if test "$t" == "alias"; then
		local a="$( alias "$f" | cut -d "'" -f 2 )"
		if test "$a" == "call $f"; then
			unalias "$f"
			t="$( type -t "$f" 2>/dev/null )"
		fi
	fi

	if test "$t" != "function"; then
		local s="$HOME/etc/bash/$f.sh"
		if test -r "$s"; then
			source "$s"
		fi
	fi

	"$f" "$@"
}


#{{{1 software setup

export LANG="en_US.UTF-8"
export LANGUAGE="$LANG"
export LC_COLLATE="C"

export LESS='-X -F -M -R -f -a -j4'
export PAGER="less $LESS"
export MANPAGER="$PAGER"
#export MANPAGER="col -b | view -c 'set ft=man nomod nolist' -"
[ -x /usr/bin/lesspipe ] && eval "$(lesspipe)"

export EDITOR="vim"
export SVN_EDITOR="$EDITOR"
export GREP_OPTIONS='--exclude="*.svn-base"'

# paths
export DERELICT_DIR='/home/sft/d/derelict'
export PKG_CONFIG_PATH="/usr/local/lib/pkgconfig:/usr/lib/pkgconfig:$PKG_CONFIG_PATH"
export CHOICESPATH="${HOME}/.Choices:/usr/local/share/Choices:/usr/share/Choices"

# dev
export ACLOCAL_FLAGS='-I /usr/local/share/aclocal'

# shell
export INPUTRC="$HOME/.inputrc"
if false && [ -f /etc/bash_completion ]; then
	. /etc/bash_completion
fi

export DMD_DIR='/opt/dmd'


#{{{1 path

add_to_path \
		-h "$HOME/bin" \
		-h "$DMD_DIR/bin" \
		-t "/usr/sbin" \
		-t "/sbin" \
#		-h "/usr/local/lib/cw" \

alias dif="$HOME/etc/scripts/dif.sh"
alias undeaf="$HOME/etc/util/undeaf.sh"
alias path2tag="$HOME/etc/scripts/path2tag.pl"
alias vimv="$HOME/etc/scripts/vimv.sh"
alias web="$HOME/etc/scripts/web.pl"


#{{{1          aliases and functions that mask existing programs

alias mv='mv -i'

alias tig='tig --all'
alias xxd='xxd -c $(( (($COLUMNS - 10)/7)*2 ))'
alias wget='wget -c --timeout=15 --wait=0 --tries=0'
alias xpdf='xpdf -z width'
#alias tar='tar --exclude=.svn --exclude=CVS'

if [ "$OSTYPE" == "linux-gnu" ]; then

alias grep='grep --exclude="*.svn-base" --devices=skip'
alias cp='cp -i --preserve=timestamps'

function rm()
{ #{{{

	local file_count=0
	local ok=true
	for i in "$@"; do
		if ! expr match "$i" "\-*" > /dev/null; then
			if test -e "$i"; then
				let file_count++
			else
				/bin/rm "$i"
				ok=false
			fi
		fi
	done; unset i
	if ! $ok; then
		if test $file_count -gt 0; then
			echo "and $file_count more item(s) not rm'ed"
		fi
		return
	fi

	if test $file_count -eq 0; then
		echo "no files" > /dev/stderr
		return
	elif test $file_count -gt 1; then
		ls -d "$@"
		read -p "remove $file_count items (y/n) [y]? " answer
		test "$answer" == "y" -o "$answer" == "" || return
	fi

	/bin/rm "$@"

} #}}}

alias emerge='sudo emerge -v --ask'

fi

function head()
{ #{{{
	if test "$1" == ""; then
		`which head` -$(( 2 * $LINES / 3 )) "$@"
	else
		`which head` "$@"
	fi
} #}}}

#{{{1 ls

if [ "$OSTYPE" == "linux-gnu"  -a  "$TERM" != "dumb" ]; then
	eval "`dircolors -b`"
	alias ls='ls --color=auto'
fi

alias A='a -A'  # single column if fits screen, multi otherwise
alias D='d -A'  # ls long listing format
alias F='f -A'  # with size/date/time info
alias Z='Z -A'  # like F, but ordered by date

# the lowercase versions (that don't show hidden files):
function a() {
    local n=$( ls "$@" | wc -l )
	if test $n -gt 0; then
		if test $n -lt $(( $LINES / 2 )); then
			ls -1F "$@"
		else
			ls -F "$@"
		fi  
	fi
}
alias c='a *.{c,d,h,sh,pl,pm,java,cpp,cxx,C} 2>/dev/null'
alias d='ls -lF'
function f() {
	\ls -FGhln --color=always --time-style=long-iso "$@" |
	sed 's/^[^\ ]\+\ \+[^\ ]\+\ \+[^\ ]\+\ \+\(....\)\ \(20[^\ ]\+\ [^\ ]\+\)\ \(.*\)$/\2\ \ [0;37m\1\ \ \3/'
}
alias z='f -rt'

# deprecated stuff:
#alias _sd='find -type d -maxdepth 1 -name "[^\.]*" -print0 | xargs -0 du -sc | sed "s/\.\///" | sort -n'
#alias _sf='find -type f -maxdepth 1 -name "[^\.]*" -print0 | xargs -0 du -sc | sed "s/\.\///" | sort -n'
#alias sz='_sf; ls -F | grep -q \/$ && _sd; echo $(echo $(du -s .)|cut -d \  -f 1) $(du -sh .)'
#alias dz='du -shc * | grep -v "^0" | grep "[0-9][MG]"'


#{{{1 abbreviations

alias p='ps -AH --format "%U %p %a"'
alias l='less'
alias cn='cat > /dev/null' # quick volatile writepad
alias data='date +%Y-%m-%d'

alias u='if test $( ls *.rar 2>/dev/null | wc -l ) == 1; then rar x *.rar && rm *.rar; elif test $( ls *.zip 2>/dev/null | wc -l ) == 1; then unzip *.zip && rm *.zip; else echo \?; fi'

alias pgw='ping gw'
alias pgo='ping google.com'
alias links='which links >/dev/null && links || elinks'

alias gk='gitk --all &'
alias gc='git commit'
alias gca='git commit -a'
alias gci='git commit --interactive'
alias gco='git checkout'
alias gs='git status -a'
alias gd='git diff'
alias gsac='git stash apply && git stash clear'
alias gsd='git_stash_do "svn dcommit"'
alias gsr='git_stash_do "svn rebase"'
function git_stash_do()
{
	if git status | grep -q 'modified:'; then
		for i in stash "$1" "stash pop"; do
			echo "[$i]"
			git $i || break
		done
	else
		git $1
	fi
}

alias configure='nice ./configure --disable-nls'
alias mk="nice make -j `show cpus`"
alias cm='configure && mk'
alias conf='./configure --help && read a && configure $a'
alias confh='./configure --help | less'
alias cmi='conf && mk && mki'
alias qpro='rm Makefile *.pro; qmake -project && qmake && make clean'

alias mp='mplayer'
alias mpf='mplayer -fs -osdlevel 0'
alias mpdvd='mplayer -identify dvd://1 -dvd-device "$PWD"'
alias mpq='mplayer -nosound -osdlevel 0'
alias mpr='ls -Q | rl | xargs mplayer -fs'
alias mprq='ls -Q | rl | xargs mplayer -fs -ao null'
alias ponte='mplayer mms://200.246.9.2/pontelive'

function v() {
	if test "$1"; then
		vim -o "$@"
	else
		vim .
	fi
}

if test -e /etc/debian_version; then

	alias apt='sudo aptitude'

elif test -e /etc/slackware-version; then

	alias pkg='web --linux-packages'
	alias sl='web --slackware'

	alias sip='sudo installpkg'
	alias srp='sudo removepkg'
	alias sup='sudo upgradepkg'

fi


#___
#}}}
#{{{  version control

alias svnbk='svnadmin dump /home/svn | bzip2 -9 > bart.svndump.`date +%Y-%m-%d`.bz2'

function svndiff() {
	svn diff $args \
		--diff-cmd /usr/bin/diff -x \
		"-U 5 -rpbB --ignore-all-space --ignore-blank-lines" \
		"$@"
}
function svndif_tmp() {
	local args
	if test "$1" == "-h"; then
		shift
		args="-r BASE:HEAD"
	fi
	tmp=`mktemp /tmp/svndif.XXXXXX`
	svndiff $args "$@" >| "$tmp" || return
	test -s "$tmp" && echo "$tmp" || /bin/rm "$tmp"
}
function svndif() {
	tmp=`svndif_tmp "$@"`; test "$tmp" || return
	vim +'set filetype=diff' +'set nomodified' "$tmp"
	/bin/rm "$tmp"
}

function svnci() {
	tmp=`svndif_tmp "$@"`; test "$tmp" || return
	SVN_EDITOR="vim -o \"$tmp\" +\"set filetype=diff\"" svn commit "$@"
	/bin/rm "$tmp"
}

function ci() {
	if test -d .svn; then
		svnci "$@"
	elif test -d CVS; then
		echo 'nao sei fazer CVS ainda'
	else # supoe git
		tmp=`mktemp /tmp/gitdif.XXXXXX` || return
		git-diff "$@" >| "$tmp" || return
		if test -s "$tmp"; then
			tmp2=`mktemp /tmp/gitdif.XXXXXX` || return
			echo "#!/bin/sh" >> $tmp2 || return
			echo "vim -c \"set filetype=diff\" -c \"set nofen\" -o \"$tmp\" \"\$@\"" >> $tmp2 || return
			chmod +x $tmp2 || return
			test "$*" && quem="$@" || quem=-a
			EDITOR="$tmp2" git-commit $quem
			rm "$tmp2"
		fi
		rm "$tmp"
	fi
}

function svnst() {
	svn st "$@" | grep -v '^\?'
}

function update() {
	if test -d .svn; then
		local rev1=`svn info | grep '^Revision:' | cut -d ' ' -f 2`
		echo "Local revision: $rev1"
		svn up "$@"
		local rev2=`svn info | grep '^Revision:' | cut -d ' ' -f 2`
		if test "$rev1" != "$rev2"; then
			local dif="svndif -r $rev1:$rev2"
			echo "$dif"
			echo "`date +%Y-%m-%d`  $dif" >> .svn/_updates
		fi
	elif test -d .git; then
		git pull "$@"
	elif test -d CVS; then
		cvs -z3 -q up -dP "$@" | grep -v '^\?' #grep -v '^cvs\ update:\ Updating\ ' #grep nao funciona pq ta no stderr
	else
		echo 'Found no ".svn", "CVS", or ".git" directory.'
		false
	fi
}

#export CVS_RSH=ssh
#export CVSROOT=:ext:9h:/home/9hells/cvsroot

#}}} version control
#{{{ #TODO: organizar o resto abaixo..
# aliases
alias pgr='pgrep -l'
alias cdrec='sudo cdrecord -v dev=/dev/cdrom'
function q4() {
	if true; then
		# metodo menos drastico, impede somente DNS, mantendo conexoes atuais abertas
		a='/etc/resolv.conf'
		b='/etc/__disabled__resolv.conf'
		sudo mv $a $b || return
		(sleep 90s; sudo mv $b $a) &
	else
		sudo ifconfig eth0 down || return
		(sleep 90s; sudo ~/etc/etc/neton) &
	fi
	/home/games/quake4/quake4
}


#{{{1          util

# quick edit&reload this file
alias ea='vim ~/.bashrc && source ~/.bashrc'

alias rawbatch='ufraw-batch --wb=camera --exposure=auto --out-type=jpeg --compression=80'

alias raw2jpg='rawbatch --size=`show res` --out-path=.. *'

#TODO: move this to foto.pl
alias jpg2raw='test -d shot && cd shot; for i in *; do test -f ../`echo $i|sed "s/.cr2$/.jpg/"` || mv -v $i ../.qiv-trash/; done; unset i'

alias kb='~/etc/desktop/switch-kbmap.sh'

job()  # manage background jobs
{ #{{{
	spool_dir="/tmp/jobs"

	if test -z "$*"; then
		ls "$spool_dir"
		return
	fi

	let max_jobs=`show cpus`+1

	test -d "$spool_dir" || mkdir "$spool_dir" || exit

	while test $( ls "$spool_dir" | wc -l ) -ge $max_jobs; do
		sleep 1s
	done

	(
		job=$( mktemp "$spool_dir"/job.XXXXXX )
		test -f "$job" || exit
		"$@"
		rm "$job"
	)&
} #}}}

function lddr()  # ldd "recursivo": faz ldd das bibliotecas nao-padrao mostradas pelo ldd
{ #{{{
	for i in "$@"; do
		ldd $( ldd "$i" | cut -d '>' -f 2 | cut -d ' ' -f 2 | grep -v '^/\(usr\|lib\)' )
	done; unset i
} #}}}

alias reconnect='sudo kill `pidof dhclient`; sudo ifconfig eth0 down; sudo dhclient'
#alias reconnect='sudo ifconfig eth0 down; sudo ifconfig eth0 192.168.1.4 netmask 255.255.255.0 && route add default gw 192.168.1.1'

function do_crun() {
	local cc="$1"; shift
	local aout=`mktemp /tmp/crun.XXXXXX`
	if $cc "$@" -o "$aout" -; then
		"$aout"
		rm "$aout"
	fi
}

function crun() {
	do_crun "gcc -x c" "$@"
}

function Crun() {
	do_crun "g++ -x c++" "$@"
}


#{{{1          misc

#{{{2 warn about uncommited changes

uncommited=""
for dir in $working_dirs; do
	if svn st $dir|grep '^M'|head -1>/dev/null; then
		uncommited="$uncommited $dir"
		break
	fi
done; unset dir
if test -n "$uncommited"; then
	echo "uncommited: $uncommited"
fi
unset uncommited

#}}}

alias ph='vi ~/src/txt/phonebook.txt'

alias t='source ~/etc/scripts/untar.sh'
alias grepsmallnear='find . -type f -maxdepth 2 -size -10k -not -name "* *" | xargs grep'
#alias r='xset r'
#alias k='sudo kbdrate -r 30 -d 250'
#alias caps='xmodmap -e "keysym Caps_Lock = Escape"'
alias caps='xmodmap -e "remove Lock = Caps_Lock" -e "keysym Caps_Lock = Escape"'
alias geom="xwininfo -root | sed -rn '/-geometry/s/[^0-9]*([0-9]+x[0-9]+).*/\1/p'"
alias 2view='convert -quality 80 -resize `geom`'
alias dt='~/etc/scripts/dtool.pl'
alias vd='dt vd'

function waitload() {
	while true; do
		local threshold=40
		local load=`cat /proc/loadavg | sed 's/\.//;s/^0//' | cut -d " " -f 1`
		if test $load -gt $threshold; then
			echo "load($load) > threshold($threshold)"
			sleep 5s
		else
			echo "load($load) < threshold($threshold)"
			break
		fi
	done
}

#alias mem='free; kill `pidof WMxmms`; sleep 1s; WMxmms &; sleep 1s; dk kill; sleep 1s; ml &; sleep 3s; free'
alias updb='sudo updatedb &'



export GDK_USE_XFT=1

alias fu='du -sc * | sort -n'
#alias www='webfsd -d -F -p 8080 -r .'
alias ntop='sudo jnettop'
#alias w1='cd ~/fotos/incoming && sudo gphoto2 -P'
#alias w1='source /home/barrett/bin/w1'

#alias dif='diff --unified=5 --show-c-function --recursive --ignore-all-space'
#alias dif='diff --unified=5 --show-c-function --recursive --ignore-space-change --ignore-blank-lines --ignore-all-space'

alias g9='gkrellm -w -s 9h &'
alias irc='irssi -n barrett9h -c irc.freenode.net'
#alias lm='nice lame -m s -v -h -V 2 -b 32 -B 320'
alias lm='for i in *.wav; do nice lame -v "$i" "`echo $i | sed s/wav$/mp3/`"; done; unset i'
alias treo='nice lame -m j -v -f'
#alias v='gvim -geom 80x50 +"set guioptions-=T" +"set guioptions-=m" -font "-misc-fixed-medium-r-semicondensed-*-*-120-*-*-c-*-iso8859-1"'

alias mame='xmame.x11 -rompath .'

function mkcd() { mkdir "$1" && cd "$1"; }
function cd..() {
	dir="$PWD"
	cd .. || return
	read -p "rm -rf \"$dir\" (y/[n])? " || return
	test "$REPLY" == "y" -o "$REPLY" == "r" || return
	rm -rf "$dir"
}

function _x() {
	echo "$*"
	echo "$*" | /bin/sh
}

function Seq() {
	seq $* | sed s/^[0-9]$/0\&/
}

alias cdq='cdparanoia -Q'
function cdp() {
	test "$1" -gt 1 && (
		for i in $(seq $* | sed s/^[0-9]$/0\&/); do
			cdparanoia -z $i $i.wav
		done; unset i
		cdeject
	)
}

function bk() {
	bkdir="$HOME/BACKUP"
	let n=$( echo $1 | wc -c ) - 1
	if test / == $( echo $1 | cut -b $n ); then
		dir="$( echo $1 | cut -b 1-$(($n - 1)) )"
	else
		dir="$1"
	fi
	
	if test -d "$dir"; then
		basename="$bkdir/$dir.`date +%Y-%m-%d`"
		name="$basename.tgz"
		if test -e "$name"; then
			for i in a b c d e f g h i j; do
				name="$basename$i".tgz
				if test ! -e "$name"; then
					_x " tar cfz \"$name\" \"$dir\" "
					break
				fi
			done; unset i
		else
			_x " tar cfz \"$name\" \"$dir\" "
		fi
	else
		echo bk: $dir: not a directory
		false
	fi
}


# TRASH trash
# which() {
#	alias | grep "^alias\ $1="
#	declare -f | /usr/bin/which --all --read-functions $@ 2> /dev/null
# }
#export -f which

export LS_COLORS='no=00:fi=00:di=01;31:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jpg=01;35:*.png=01;35:*.gif=01;35:*.bmp=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.png=01;35:*.mpg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:';

alias tetrinet='tetrinet -noslide -fancy bart9h games03.click21.com.br'

alias k='sudo kbdrate -r 30 -d 200'
alias black='xsetroot -solid black'


#{{{1 shell setup

if test -t 0 ; then
	stty -ixon -ixoff
fi

#test "$TERM" == "vt100" && export TERM="xterm"

# append on history, instead of overwriting
shopt -s histappend

# check the window size after each command,
# updating $LINES and $COLUMNS if necessary
shopt -s checkwinsize

# vi mode for command prompt editing
set -o vi

# prohibits overwriting files with '>'.
# use '>|' to force overwriting.
set -o noclobber

#{{{ ulimit

 MemTotal=$( cat /proc/meminfo | sed  '/^MemTotal/!d;s/^[^0-9]*\([0-9]\+\).*/\1/' )
SwapTotal=$( cat /proc/meminfo | sed '/^SwapTotal/!d;s/^[^0-9]*\([0-9]\+\).*/\1/' )

# core file size          (blocks, -c) 0
ulimit -c $(( 32 * 1024 ))

# max locked memory       (kbytes, -l) unlimited
ulimit -l $(( 512 * 1024 )) 2>/dev/null  #FIXME: check if I can

case "$OSTYPE" in
	*linux*)
		# file size               (blocks, -f) unlimited
		ulimit -f $(( 20 * 1024*1024 ))

		# max user processes              (-u) unlimited
		ulimit -u 1024

		# file locks                      (-x) unlimited
		if [ $BASH_VERSINFO -ge 3 ]; then
			ulimit -x 128
		fi

		# data seg size           (kbytes, -d) unlimited
		ulimit -d $(( $MemTotal / 2 ))

		# max memory size         (kbytes, -m) unlimited
		ulimit -m $(( $MemTotal / 2 ))

		# virtual memory          (kbytes, -v) unlimited
		ulimit -v $(( $SwapTotal + $MemTotal / 2 ))
	;;
esac


#}}}


#}}}
#{{{ the command prompt

export HISTCONTROL="ignoreboth"
PS1='\[\e[0;'$prompt_color'm\]\t [$(echo $STY|cut -d . -f 2).$WINDOW] \u@\h \w $(git-branch 2>/dev/null | grep -e "^\* ")$(git-status 2>/dev/null | grep -q "^# Change" && echo "[+]")\[\e[0m\]\n\$ '
export PS1
export THE_PS1=$PS1

if test -n "$WINDOW"; then
	PROMPT_COMMAND='test -n "$WINDOW" && screen -X title "${PWD/$HOME/~}"'
fi

function titlebar()
{
	test -n "$WINDOW" || return
	local s="$*"
	case "$s" in cd|cd\ *|ls|ls\ *|screen|screen\ *) return ;; esac
	s="`echo $s | cut -d \  -f 1`"
	screen -X title "$s"
}

if echo "$BASH_VERSION" |  grep -q '^3\.1\..*'; then
	#set -o functrace
	trap 'titlebar $BASH_COMMAND' DEBUG
fi

#}}}

_load "$HOME/.bashrc_local_post"
# vim600:foldmethod=marker:
